/*第一个输入，是一个简单的str比较，根据gdb调试，发现比较字符串*/
Border relations with Canada have never been better.
/*第二个输入，首先判断是否为6个数据，然后判断第一个数据是否为1，然后一个循环判断，要求后一个数据是前一个数据的二倍*/
1 2 4 8 16 32 
/*第三个输入简单的switch，只判断了两个，其他的感兴趣可以自己找*/
(0 207)(1,311)
/*第四个输入首先判断输入个数，第一个输入判断0-14，第一个数据传入函数，函数的返回值和第二个数据比较*/
(7 0)(3,0)
/*第五个输入要求有6个数据，然后获取每个数据的8位，当作一个table的index，下标替换后和flyers比较，我是用了大写字母的连续，当然也有别的数据，只要和我的数据&0xf之后相同就行*/
IONEFG
/*最后一个比较麻烦，我用gdb和ida才分析懂他的逻辑，这个数据存放很有技巧，node1是起始地址，然后node1+8是第二个数据的地址，node1+16是第二个数据......,以此类推
可以通过gdb就可以发现，首先要求六个数据不相等，然后经过7-i,改变数据，然后更改每个数据的地址，要求读取的数据的-8位是下一位数据的地址，然后实现数据的排列，从大到小，依次是3,4,5,6,2,1,然后7-i，最后的结果数4,3,2,1,6,5*/
4 3 2 1 6 5
